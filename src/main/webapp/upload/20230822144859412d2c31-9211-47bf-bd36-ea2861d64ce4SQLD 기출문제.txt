

   # SQLD 기출문제 #


--------------------------------------------------------------------------------------------

  [ 21회 ]


 * 객관식

 3.  NOT IN 연산에서 NULL 값이 포함되어 있을 경우, 조건식에 대해 TRUE 리턴
     ( NULL 값이 하나라도 존재하면 그로 인해 모든 조건 참이 되어 0건 반환 )
 13. SQL Server이 IDENTITY 컬럼 = IDENTITY(시작값, 증가값)
      해당 컬럼에 값을 INSERT 할 경우 ERROR 발생
      Oracle에서 NULL 값은 CHECK 조건 무시
 15. 문제 및 해설 확인.
 21. NATURAL JOIN에서 사용된 열은 접두사(식별자) 불가.
 22. 문제확인 - 같은 문제 재출시되면 청약자가 정답 인정.
 26. FROM 절은 SELECT 절과 항상 짝을 이룸.
 27. NULL끼리, 또는 NULL과의 비교연산 자체가 불가. (False)
 28. 서브쿼리 WHERE 절에서도 사용 가능.

                                                                
                                                                                                    27 / 29 = 92점

 * 단답형

 1. 문제확인 - NULL값 연산에서 제외, 유사 문제로 만약 A 테이블 V1 칼럼
                   뒤에 공백이 있는 경우 TRIM 함수 이용, 공백 제거 후 비교하여 추출.
 4. 문제확인 - 전체 1그룹, DNAME 3그룹 (40.OPERATIONS는 조인 실패),
                   JOB 5그룹, DNAME+JOB 9개 총 18개
 7. COUNT(*) 시 조건에 맞는 결과가 없을 경우 0 반환


                                                                                                     5  /  7 = 70점
               
--------------------------------------------------------------------------------------------

  [ 30회 ]

 2.  반정규화 기법 - 테이블 병합, 테이블 분할, 테이블 추가(중복, 통계, 이력, 부분)
                          칼럼 추가(중복, 파생, 이력테이블(기능성), PK에 의한, 오작동 위한)
                          중복 관계 추가
 6.  1:N 관계에서 1쪽은 N쪽의 모든 데이터를 포함하지만 N쪽은 1쪽의 모든 데이터 포함 X
 7.  반정규화 대상 - 범위처리 빈도, 대량 범위처리, 통계성 프로세스, 테이블 조인 多
 11. NUMBER 타입 칼럼에 문자 형식으로 비교 가능, 문자 간 크기 비교 가능.
      문자타입 칼럼에 숫자 형식 비교하려면 모든 칼럼이 숫자 타입으로만 입력되어 있어야 함.
 12. 스칼라 서브쿼리에서 한 번의 값 전달에 2개 이상의 행이 반환될 수 없음. 단일행, 단일칼럼만 가능
 15. IN 연산에 NULL이 있을 시 무시하고 연산. ([컬럼=인수]의 OR 반복연산, 칼럼=NULL 비교 불가)
 16. 실행계획 수행순서 = [ 선행인덱스→선행테이블액세스→후행인덱스→후행액세스→조인→반복 ]
 23. COMMIT, ROLLBACK = TCL(DCL), TRUNCATE = DDL
 26. ROWNUM 함수 WHERE 절에서 사용해야 함.
 30. 모든 회원을 구하라 했는데 1번은 INNER JOIN을 해서 구매안한 고객은 검색 X.
 33. PK가 2개의 칼럼으로 구성되어 있는데 4번은 1개의 칼럼에만 조건을 걸어서 여러 행 반환 가능.
 35. Cross Join과 Natural Join도 Where절에서 조건 걸 수 있음. (조인 조건을 못거는 것 뿐임)
 
42. MERGE INTO 대상테이블
          USING 대상 테이블에 삽입 할 테이블
          ON 비교할 키 값
      WHEN MATCHED THEN
          UPDATE SET 대상 테이블에 키 값 이미 존재 시, 변경해 줄 컬럼과 값
          DELETE
      WHEN NOT MATCHED THEN
          INSERT(칼럼, 칼럼, 칼럼) VALUES(인수, 인수 인수);

      MERGE INTO 구문은 테이블에 데이터를 조회하여 이미 존재하는 키 값이면
      수정할 데이터를 입력하고, 존재하지 않으면 새로 삽입하게 해주는 구문이다.

      * MERGE INTO 구문에서 DELETE 절은 UPDATE 절에 종속된다.
        (UPDATE가 실행된 건에 한해서만 DELETE가 동작함)

 47. Default 값 = INSERT 문에서 컬럼 명시 없이 삽입 OR 컬럼 명시 후 Default 입력 시 입력되는 값.
                      (컬럼 명시 후, NULL 입력시, NULL이 입력됨.)

                                                                                                     45 / 50 = 90점


--------------------------------------------------------------------------------------------

  [ 34회 ]


 7.  식별자 관계 : 자식의 주식별자로 상속, NULL값 X, 부모에 종속, 상속받은 주식별자를
                        타 엔터티에 이전 가능
 12. 서브쿼리를 벗어나면 사라지는 값들은 서브쿼리의 SELECT절에 명시되지 않은 칼럼들 뿐.
 16. [MERGE JOIN = Sort Merge Join], WHERE절에 EQUI 조건 한 개만 있을 시 Hash 보다
                                                    NL이 반드시 좋다고 할 수 없음.
 23. 기본적으로 COUNT(*)시, 결과가 없으면 0이 출력되지만,
      이 문제에서는 HAVING은 GROUP으로 묶어 조건에 만족되는 것들로 결과 집합을 만들어 반환하는데,
      만족하는 것이 없어 아예 반환 자체가 안되기 때문에, 셀 수 있는 구조 자체가 없어 공집합이 반환된다.
 27. WHERE절에서 집계함수 사용 불가. (WHERE절의 서브쿼리 내에서는 가능)
 31. CROSS JOIN = 왼쪽 테이블의 한 행당 오른쪽 테이블 모든 행 한 번씩 붙여서 출력 (N*M)
      OUTER JOIN이랑 전혀 다름.
 33. Oracle 에서는 Like 'A%'로 조회 시, 대소문자 구분. (SQL Server는 구분 안함)
 36. [ DELETE FROM 테이블명; ]에서 FROM은 생략 가능 → [ DELETE 테이블명; ] 가능
      전체 칼럼을 명시(INSERT 구문에서 칼럼명 생략)할 경우, Default 값 있더라도 값 입력해야 함.
      → 만약 칼럼이 명시된 상태에서 Default 값 주고 싶으면 인수 입력에 Default 입력하면 됨.

 42. PARTITION BY 대신 GROUP BY를 사용할 수는 있지만, GROUP BY 되어진 결과 집합 내에서
      WINDOW 함수를 사용하는 것이라 전체 원본 테이블에서 병행 사용이 가능하다고 보기는 힘듦.
      명확하지 않은 표현이기 떄문에 적절하지 않은 것 맞음.

 47. CTE(Common Table Expression)를 재귀 호출함으로써 상위부터 하위 방향 전개

	WITH 테이블명_ANCHOR AS
	( SELECT 하위칼럼명, 칼럼명, 상위칼럼명, 0 AS LEVEL
	FROM 테이블명
	WHERE 상위칼럼명 IS NULL /* 재귀 호출의 시작점 */
	UNION ALL
	SELECT R.칼럼명, R.칼럼명, R.계층칼럼명, A.LEVEL + 1
	FROM 테이블명_ANCHOR A, 테이블명 R
	WHERE A.하위칼럼 = R.상위칼럼 )

                                                                                                     48 / 50 = 96점

--------------------------------------------------------------------------------------------